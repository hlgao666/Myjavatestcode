线程通信

解决方式1：并发协作模型：生产者-消费者模式（管程法）
 * 借助缓冲容器
解决方式2：并发协作模型：生产者-消费者模式（信号灯法）
 * 借助标志位

死锁，过多的同步可能造成相互不释放资源
 * 从而造成等待，一般发生于同步块中持有多个对象的锁
 * 避免：不要在同一个代码块中，同时持有多个对象的锁

Quartz：任务调度框架。
主要有三个核心概念：调度器、任务和触发器。
三者关系简单来说就是，调度器负责调度各个任务，到了某个时刻或者过了一定时间，触发器触动了，特定任务便启动执行。

HappenBefore：执行代码的顺序可能与编写代码的顺序不一致，即虚拟机优化代码顺序，则为指令重排
但必须要求指令对应的变量是相互独立，没有依赖的。e.g. a=1; flag=0;
1.在虚拟机层面，为了尽可能减少内存速度远低于CPU处理速度而带来的CPU空闲的情况，虚拟机会将指令重排，后面的代码可能先执行。
2.硬件层面，CPU会将接收到的一批指令按照其规则重排。

Volatile:保证数据的同步（可见性），数据修改后立即传回主内存，保证其他指令使用的变量永远都是最新的数据。
可以避免指令重排，但不能保证数据的原子性。
适用于CPU高度忙碌，没有时间同步更新主内存的数据

DCL单例模式：在懒汉式基础上加入并发控制，保证在多线程环境下，对外存在一个对象
1.构造器私有化--->避免外部new构造器
2.提供私有的静态属性--->存储对象地址
3.提供公共的静态方法--->获取属性

inheritableThreadLocal拷贝一份数据给子线程，不共享对象，仅仅是拷贝了数据（1份）

ReentrantLock可重入锁：有计数器，看是哪个线程占用了锁，如果是自身，则不用等待，否则需要等待。
锁可以延续使用，每个锁有自己的计数器

悲观锁：SynChronized独占锁或悲观锁
乐观锁的实现：
CAS(Compare and Swap)比较并交换操作(CPU指令)：效率比加锁效率高
有三个值：一个内存V值、一个旧的数据值A、一个待更新的值B。
现获取内存的V值，若A与V相同，则将A更换为B，否则什么都不做。
注意：ABA问题。若某线程先将A更改为B，再将B更改为A,则不意味着A的值曾经没有被线程修改过。